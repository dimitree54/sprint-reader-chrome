# Story 1.1: Reader streaming and UI stability

Status: Draft

## Story
**As a** user of the reader,
**I want** reliable streaming, accurate progress/time display, and responsive controls,
**so that** I can read without glitches, stalls, or UI inconsistencies.

## Acceptance Criteria
1. Streaming uses browser-safe scheduling (no `setImmediate` errors) and does not flicker `isStreaming` false→true on init.
2. Appending tokens is race-safe; tokens and wordItems grow consistently under rapid callbacks.
3. Reader state reset restores all preferences (pauseAfter*, chunkSize) and UI defaults (optimalFontSize).
4. Progress/time labels update when WPM or timing preferences change; play button label reflects status.
5. Changing the current index while playing reschedules the timer with a correct delay; cadence remains accurate.
6. Selection loader does not start streaming on empty selections and resets store state instead.
7. Theme and WPM controls use null-safe event handling; preferences persist and the UI updates immediately.
8. Reader messaging `refreshReader` does not cause sender-side lastError and responds as expected.
9. The reader unsubscribes from store updates on unload; no leakage during hot reloads/tests.
10. Quality gates: `npm run lint`, `npm run typecheck`, and `npm test` pass (OpenAI tests require a valid `OPENAI_API_KEY`).

## Tasks / Subtasks
- [ ] Streaming token processing
  - [ ] Replace `setImmediate` recursion with `setTimeout(() => ..., 0)` in `src/reader/streaming-text.ts` to avoid browser ReferenceError. (AC: 1)
  - [ ] Consolidate initialization setState calls to avoid `isStreaming` false→true flicker and reduce redundant updates. (AC: 2)
  - [ ] Append tokens via functional `setState` to prevent races: `useReaderStore.setState(s => ({ tokens: s.tokens.concat(words) }))`. (AC: 2)
- [ ] Reader state and timing accuracy
  - [ ] Ensure `reset()` in `src/reader/state/reader.store.ts` restores `pauseAfterComma`, `pauseAfterPeriod`, `pauseAfterParagraph`, `chunkSize`, and `optimalFontSize` from defaults. (AC: 3)
  - [ ] In `src/reader/playback/playback.service.ts`, track `index` in `lastWatched` and include in cadenceChanged; compute delay using a single `const s = useReaderStore.getState()` snapshot. (AC: 5)
  - [ ] In `src/reader/text.ts`:
    - [ ] Update `recalculateTimingOnly` comment to reflect local (non‑AI) preprocessing; reuse a captured store variable. (AC: 5)
    - [ ] Clamp the playback index after rebuild to avoid out‑of‑bounds when `wordItems` shrink. (AC: 5)
- [ ] Selection loader and controls resilience
  - [ ] In `src/reader/selection-loader.ts`, add explicit return type for `getCurrentSelectionFromBackground(): Promise<BackgroundResponse['selection'] | null>`. (AC: 6)
  - [ ] Guard empty selections: if `tokens.length === 0`, call `useReaderStore.getState().reset?.()` and return rather than starting streaming. (AC: 6)
  - [ ] In `src/reader/ui/controls.ts`, use `event.currentTarget` for slider/theme handlers to avoid possibly‑null element capture and improve typing. (AC: 7)
  - [ ] In `src/reader/preferences.ts`, use store actions (`updatePreferences`, `setTheme`) and guard `applyThemeToElement` with `document` presence. (AC: 7)
- [ ] Rendering updates on preference changes
  - [ ] In `src/reader/ui/renderer.ts`:
    - [ ] Cache `playButton` as `HTMLButtonElement` in `getRequiredElements()` and reuse it. (AC: 4)
    - [ ] Extend minimal‑diff comparison to include: `wordsPerMinute`, `pauseAfter*`, `chunkSize`, `highlightOptimalLetter`, `highlightOptimalLetterColor`, `wordFlicker`, `wordFlickerPercent`. (AC: 4)
- [ ] Reader lifecycle and messaging
  - [ ] In `src/reader/index.ts`, capture `const unsubscribe = initRenderer()` and `window.addEventListener('beforeunload', unsubscribe)`. (AC: 9)
  - [ ] In `src/reader/messages.ts`, respond to `refreshReader` using async sendResponse or do not return true if not sending a response; ensure no lastError. (AC: 8)

## Dev Notes
Relevant architecture context and constraints (do not assume beyond cited docs):
- Execution Contexts and shared modules define background/content/popup/reader with shared services. [Source: architecture.md#1.-high-level-overview]
- The reader is store‑driven via Zustand; UI updates centralize in `renderer.ts` and playback loop in `PlaybackService`. [Source: architecture.md#3.-execution-contexts]
- Cross‑cutting core services wrap runtime/browser APIs; state uses centralized defaults. [Source: architecture.md#4.-cross-cutting-modules]
- Build & packaging generates per‑browser bundles with esbuild; do not embed secrets in production. [Source: architecture.md#5.-build-&-packaging-pipeline]
- Testing strategy includes unit via Vitest and end‑to‑end via Playwright; OpenAI tests require real `OPENAI_API_KEY`. [Source: architecture.md#7.-testing-strategy]

Source tree and files impacted:
- `src/reader/streaming-text.ts`, `streaming-text-processor.ts`, `state/reader.store.ts`, `playback/playback.service.ts`, `selection-loader.ts`, `ui/renderer.ts`, `ui/controls.ts`, `preferences.ts`, `index.ts`, `text.ts`, `messages.ts`.

Testing
- Unit: add coverage for `reset()` fields and playback delay computation with changed index; renderer diff keys if applicable.
- E2E: run Playwright scenarios that exercise:
  - Starting streaming (with and without `OPENAI_API_KEY`), ensure no flicker and no `setImmediate` errors.
  - Changing WPM/pauses updates progress/time labels.
  - Seeking/changing index reschedules cadence smoothly.
  - Theme and WPM controls act without console errors.

Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-27 | 0.1 | Draft story created | Scrum Master |

