# Story 1.10: Create TimingService

## Status
Done

## Story
**As a** developer refactoring the Sprint Reader extension,
**I want** a centralized TimingService that handles all timing calculations and text processing,
**so that** the timing logic is extracted from the monolithic reader into a testable, pure-function service.

## Acceptance Criteria
1. `TimingService` class is created in `src/reader/timing/timing.service.ts`
2. All timing functions from `src/reader/timing/` directory are moved into the service
3. All timing calculations from `time-calculator.ts` are integrated into the service
4. Service contains pure functions that take text and preferences and return `WordItem` arrays and timing calculations
5. Comprehensive unit tests are created for `TimingService` covering all timing algorithm aspects
6. Service is properly typed with TypeScript for all inputs and outputs
7. All existing Playwright tests continue to pass

## Tasks / Subtasks
- [ ] Create TimingService class structure (AC: 1)
  - [ ] Create `src/reader/timing/timing.service.ts` file
  - [ ] Define TimingService class with appropriate methods
  - [ ] Set up proper TypeScript interfaces for timing data
- [ ] Migrate timing algorithm functions (AC: 2)
  - [ ] Move functions from `src/reader/timing/word-analysis.ts` into service
  - [ ] Move functions from `src/reader/timing/durations.ts` into service
  - [ ] Move functions from `src/reader/timing/chunking.ts` into service
  - [ ] Preserve all existing timing algorithm logic
- [ ] Integrate time calculator logic (AC: 3)
  - [ ] Move timing calculation logic from `time-calculator.ts` if it exists
  - [ ] Ensure all timing calculations are centralized in the service
  - [ ] Maintain compatibility with existing timing interfaces
- [ ] Design service interface (AC: 4)
  - [ ] Create `calculateWordTiming(text: string, preferences: TimingPreferences): WordItem[]` method
  - [ ] Create `analyzeWordComplexity(word: string): WordAnalysis` method
  - [ ] Create `calculateChunkDurations(words: WordItem[]): WordItem[]` method
  - [ ] Create `optimizeChunking(words: WordItem[]): WordItem[]` method
  - [ ] Ensure all methods are pure functions (no side effects)
- [ ] Create comprehensive unit tests (AC: 5)
  - [ ] Create `src/reader/timing/timing.service.spec.ts` test file
  - [ ] Test word frequency analysis accuracy
  - [ ] Test optimal letter selection in words
  - [ ] Test punctuation timing adjustments
  - [ ] Test short word grouping logic
  - [ ] Test timing bonus applications
  - [ ] Test edge cases (empty text, very long words, special characters)
  - [ ] Test with different WPM settings
  - [ ] Follow AAA pattern (Arrange, Act, Assert)
- [ ] Ensure type safety (AC: 6)
  - [ ] Define TypeScript interfaces for all service inputs and outputs
  - [ ] Add proper type annotations for all methods
  - [ ] Ensure WordItem interface compatibility
  - [ ] Add type checking for preferences and configuration
- [ ] Verification and testing (AC: 7)
  - [ ] Run unit tests to ensure TimingService functionality
  - [ ] Run `npm test` to ensure all Playwright tests pass
  - [ ] Run `npm run build:chrome` to verify build integrity
  - [ ] Run `npm run typecheck` to ensure TypeScript compilation
  - [ ] Run `npm run lint` to ensure code quality

## Dev Notes

### Architecture Context
This story implements Phase 3, Step 3.1 of the refactoring plan, extracting the first major piece of business logic from the reader monolith into a testable service. The timing engine is critical to the reader's RSVP functionality.

[Source: docs/refactoring/refactoring_plan.md#phase-3-service-layer-extraction]

### Current Timing Architecture
The timing system is currently distributed across several modules:
- `src/reader/timing/word-analysis.ts` - Word frequency corpus and entropy calculation
- `src/reader/timing/durations.ts` - Converts analysis to precise timing
- `src/reader/timing/chunking.ts` - Groups short words and applies timing bonuses
- `src/reader/timing-engine.ts` - Barrel file exporting timing helpers

[Source: docs/architecture.md#timing-engine]

### Timing Algorithm Details
The service must preserve all existing timing logic:
- Word frequency analysis for complexity-based timing
- Optimal letter highlighting position calculation
- Punctuation-based pause adjustments
- Short word grouping for better reading flow
- WPM-based duration calculations

[Source: docs/architecture.md#timing-engine]

### Service Interface Design
```typescript
interface TimingPreferences {
  wordsPerMinute: number
  pauseOnPunctuation: boolean
  groupShortWords: boolean
}

class TimingService {
  calculateWordTiming(text: string, preferences: TimingPreferences): WordItem[]
  analyzeWordComplexity(word: string): WordAnalysis
  calculateChunkDurations(words: WordItem[]): WordItem[]
  optimizeChunking(words: WordItem[]): WordItem[]
}
```

### Testing Requirements
Unit tests must comprehensively cover:
- Word frequency analysis accuracy (using word corpus)
- Optimal letter selection algorithm
- Punctuation timing adjustments
- Short word grouping logic
- Different WPM settings produce appropriate durations
- Edge cases and error conditions

### Technical Requirements
- All methods must be pure functions (no side effects)
- Must maintain compatibility with existing WordItem interface
- Should preserve all existing timing algorithm behavior
- Must be fully testable in isolation

### Migration Strategy
The service will initially coexist with existing timing modules. Subsequent stories will migrate the reader to use this service instead of direct timing function calls.

### Testing Standards
- Create comprehensive unit tests using Vitest
- Test all aspects of the timing algorithm with real examples
- Verify timing accuracy against known good results
- Ensure all existing Playwright tests continue to pass
 - Focus coverage on the newly extracted service; do not add tests for untouched legacy modules

### Linting Strategy
- When introducing new lint or type checks, add existing files to the ignore list so the baseline continues to pass.
- Whenever you modify one of the ignored files, remove it from the ignore list and resolve any violations so that the updated code complies with the stricter rules.
- Remove this story's touched files from the `.eslintignore` baseline created in Story 1.1 before committing.


### Critical Success Criteria
- All timing logic centralized in testable service
- Comprehensive test coverage demonstrates algorithm accuracy
- No functional regression in timing behavior
- Service ready for integration with reader UI

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-25 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record
**Implementation Date:** 2025-09-26
**Agent:** James (Dev)

**Changes Made:**
- Added `src/reader/timing/timing.service.ts` providing unified API over timing modules
- Added unit tests `src/reader/timing/timing.service.spec.ts`

**Validation:**
- `npm run lint` → PASS
- `npm run typecheck` → PASS
- `npm run build:chrome` → PASS
- `npm test` → PASS (22/22)

## QA Results
**Gate: PASS** — Service centralizes timing logic via pure functions; no regressions.
