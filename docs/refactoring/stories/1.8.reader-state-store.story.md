# Story 1.8: Create Reader State Store with Zustand

## Status
Done

## Story
**As a** developer refactoring the Sprint Reader extension,
**I want** a centralized state management store using Zustand for the Reader UI,
**so that** state management is centralized, predictable, and can run in parallel with existing state during the transition period.

## Acceptance Criteria
1. Zustand is added as a dependency to the project
2. `ReaderState` interface is defined with all necessary state properties
3. Zustand store is created in `src/reader/state/reader.store.ts`
4. Store includes actions for all state mutations (play/pause, WPM changes, theme toggles, etc.)
5. Store is properly typed with TypeScript for type safety
6. Application continues to build and function normally (store not yet used by UI)
7. Unit tests cover newly created store actions/selectors and any pure helpers; untouched legacy code can remain without additional tests

## Tasks / Subtasks
- [ ] Add Zustand dependency (AC: 1)
  - [ ] Run `npm install zustand` to add Zustand state management library
  - [ ] Verify Zustand appears in dependencies in package.json
- [ ] Define ReaderState interface (AC: 2)
  - [ ] Create TypeScript interface for complete reader state
  - [ ] Include playback state (playing, paused, index, etc.)
  - [ ] Include preferences (WPM, theme, font size, etc.)
  - [ ] Include text state (words, chunks, current word, etc.)
  - [ ] Include UI state (progress, status messages, etc.)
- [ ] Create Zustand store (AC: 3)
  - [ ] Create `src/reader/state/reader.store.ts` file
  - [ ] Initialize store with default state values
  - [ ] Set up proper TypeScript integration with Zustand
- [ ] Implement state actions (AC: 4)
  - [ ] Create `togglePlay()` action for play/pause control
  - [ ] Create `setPlaybackIndex()` action for word navigation
  - [ ] Create `setWPM()` action for speed changes
  - [ ] Create `toggleTheme()` action for theme switching
  - [ ] Create `setWords()` action for loading text content
  - [ ] Create `setProgress()` action for progress updates
  - [ ] Create `setStatus()` action for status messages
  - [ ] Create `reset()` action for resetting state
- [ ] Ensure type safety (AC: 5)
  - [ ] Add proper TypeScript types to all store actions
  - [ ] Ensure state interface is properly enforced
  - [ ] Add type checking for action parameters
- [ ] Verification (AC: 6)
  - [ ] Run `npm run build:chrome` to verify build integrity
  - [ ] Run `npm run typecheck` to ensure TypeScript compilation
  - [ ] Run `npm test` to ensure existing tests still pass
  - [ ] Verify application continues to function normally

## Dev Notes

### Architecture Context
This story implements Phase 2, Step 2.1 of the refactoring plan, introducing the new state management system that will eventually replace the monolithic reader state. This is the first major step in refactoring the reader module.

[Source: docs/refactoring/refactoring_plan.md#phase-2-introduce-the-reader-state-store]

### Current Reader State Analysis
The existing reader state is managed in `src/reader/state.ts` with direct variable manipulation. The current state includes:
- Playback state (playing, currentIndex, words, chunks)
- Preferences (wordsPerMinute, theme, fontSize)
- UI state (progress, status)
- Text processing state (selection, chunks, timing)

[Source: docs/architecture.md#reader-ui-modular-architecture]

### Zustand Store Design
```typescript
interface ReaderState {
  // Playback state
  status: 'idle' | 'playing' | 'paused' | 'loading'
  playbackIndex: number
  words: WordItem[]

  // Preferences
  wordsPerMinute: number
  theme: 'light' | 'dark'
  fontSize: number

  // UI state
  progress: number
  statusMessage: string

  // Actions
  togglePlay: () => void
  setPlaybackIndex: (index: number) => void
  setWPM: (wpm: number) => void
  // ... other actions
}
```

### Technical Requirements
- Use Zustand for reactive state management
- Follow immutable update patterns
- Ensure TypeScript type safety throughout
- Design for eventual migration from existing state system
- Prepare for UI components to subscribe to store changes

### Integration Strategy
The store will initially run independently without affecting existing functionality. In subsequent stories, the old state system will be synced to this new store, then eventually the UI will be migrated to use the new store exclusively.

### Testing Standards
- Add unit tests for the new store module: validate action semantics, state transitions, and any selectors or pure helpers. Use Vitest (JSDOM not required yet).
- Focus on newly created code only; do not add tests for untouched legacy modules in this story.
- Ensure existing tests continue to pass
- Type checking must pass with new store definitions
- Application build process must remain functional

### Linting Strategy
- When introducing new lint or type checks, add existing files to the ignore list so the baseline continues to pass.
- Whenever you modify one of the ignored files, remove it from the ignore list and resolve any violations so that the updated code complies with the stricter rules.
- Remove this story's touched files from the `.eslintignore` baseline created in Story 1.1 before committing.


### Critical Success Criteria
- Zustand store operational and properly typed
- Store actions available for future integration
- No impact on current application functionality
- Foundation established for reader state migration

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-25 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record
**Implementation Date:** 2025-09-26
**Agent:** James (Dev)

**Changes Made:**
- Installed `zustand` dependency
- Added `src/reader/state/reader.store.ts` with fully typed Zustand store and actions
- Added unit tests `src/reader/state/reader.store.spec.ts`

**Validation:**
- `npm run lint` → PASS
- `npm run typecheck` → PASS
- `npm run build:chrome` → PASS
- `npm run test:unit` → PASS (store tests)
- `npm test` → PASS (22/22)

## QA Results
**Gate: PASS** — Store scaffolding complete; no runtime integration yet; zero regressions.
