# Story 1.9: Sync Legacy State to New Store

## Status
Draft

## Story
**As a** developer transitioning to the new state management system,
**I want** the legacy reader state synchronized to the new Zustand store,
**so that** both state systems stay in sync during the transition period while maintaining full application functionality.

## Acceptance Criteria
1. All state mutations in legacy `src/reader/state.ts` automatically update the corresponding values in the new Zustand store
2. Playback state changes (play/pause) sync to the new store
3. Preference changes (WPM, theme) sync to the new store
4. Text loading and processing state changes sync to the new store
5. All existing Playwright tests continue to pass
6. New store state changes are visible in browser developer console for verification

## Tasks / Subtasks
- [ ] Identify all state mutation points in legacy state (AC: 1)
  - [ ] Audit `src/reader/state.ts` for all variable assignments
  - [ ] Audit other reader files that modify state variables
  - [ ] Document all state change operations that need syncing
- [ ] Sync playback state changes (AC: 2)
  - [ ] Add store sync when `state.playing` is modified
  - [ ] Add store sync when `state.currentIndex` is modified
  - [ ] Add store sync when playback status changes
  - [ ] Ensure play/pause toggles update both state systems
- [ ] Sync preference changes (AC: 3)
  - [ ] Add store sync when `wordsPerMinute` is modified
  - [ ] Add store sync when theme settings are modified
  - [ ] Add store sync when font size or display preferences change
  - [ ] Ensure preference persistence affects both systems
- [ ] Sync text and processing state (AC: 4)
  - [ ] Add store sync when words/chunks are loaded
  - [ ] Add store sync when text processing completes
  - [ ] Add store sync when selection state changes
  - [ ] Add store sync when progress values change
- [ ] Implement synchronization mechanism
  - [ ] Import Zustand store in legacy state files
  - [ ] Add sync calls after each state mutation
  - [ ] Ensure sync calls don't cause infinite loops
  - [ ] Handle async state updates appropriately
- [ ] Add verification capabilities (AC: 6)
  - [ ] Ensure store state is accessible in browser console
  - [ ] Add debug logging for state sync verification
  - [ ] Create helper functions for inspecting store state
- [ ] Verification and testing (AC: 5)
  - [ ] Run `npm test` to ensure all Playwright tests pass
  - [ ] Test playback controls to verify state sync
  - [ ] Test preference changes to verify state sync
  - [ ] Test text loading to verify state sync
  - [ ] Run `npm run build:chrome` to verify build integrity
  - [ ] Manual browser testing to verify sync functionality

## Dev Notes

### Architecture Context
This story implements Phase 2, Step 2.2 of the refactoring plan, creating a bridge between the old and new state systems. This ensures the new store stays in sync with legacy state during the transition period.

[Source: docs/refactoring/refactoring_plan.md#phase-2-introduce-the-reader-state-store]

### Current State Management Analysis
The legacy state system in `src/reader/state.ts` uses direct variable manipulation:
- `state.playing = true/false` for playback control
- `state.currentIndex = n` for word navigation
- Direct assignment to preference variables
- Direct assignment to text and processing state

[Source: docs/architecture.md#reader-ui-modular-architecture]

### Synchronization Strategy
After each legacy state mutation, add corresponding store updates:
```typescript
// Example synchronization pattern
state.playing = true
useReaderStore.getState().togglePlay() // Sync to new store

state.currentIndex = newIndex
useReaderStore.getState().setPlaybackIndex(newIndex) // Sync to new store
```

### Technical Requirements
- Synchronization must be unidirectional (legacy â†’ new store)
- Sync calls must not cause performance degradation
- Must handle both synchronous and asynchronous state changes
- Sync must not interfere with existing functionality

### Risk Mitigation
- Changes are additive only (no removal of existing state logic)
- Legacy state system continues to drive all functionality
- New store serves as a read-only mirror during this phase
- All existing tests should continue to pass without modification

### Verification Methods
- Browser console access to store state: `useReaderStore.getState()`
- Debug logging to verify sync operations
- Manual testing of all reader functionality
- Playwright tests continue to pass (proving no functional regression)

### Testing Standards
- All existing Playwright tests must pass without modification
- Manual verification that store state updates in sync with UI changes
- No new automated tests required at this stage
- Focus on functional equivalence and sync accuracy

### Linting Strategy
- When introducing new lint or type checks, add existing files to the ignore list so the baseline continues to pass.
- Whenever you modify one of the ignored files, remove it from the ignore list and resolve any violations so that the updated code complies with the stricter rules.

### Critical Success Criteria
- Both state systems stay perfectly synchronized
- No functional regression in extension behavior
- Store state reflects all changes made through legacy system
- Foundation prepared for UI migration to new store

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-25 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*This section will be populated by the QA agent after implementation review*