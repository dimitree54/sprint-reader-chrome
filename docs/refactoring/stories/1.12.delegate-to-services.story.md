# Story 1.12: Delegate Logic to New Services

## Status
Draft

## Story
**As a** developer refactoring the Sprint Reader extension,
**I want** the existing reader components to use the new TimingService and AIPreprocessingService,
**so that** business logic is delegated to services while maintaining existing functionality during the transition.

## Acceptance Criteria
1. `text.ts` is refactored to call TimingService instead of performing timing logic directly
2. `selection-loader.ts` is refactored to call AIPreprocessingService instead of direct preprocessing
3. Results from services are stored in legacy `reader/state.ts` variables to maintain compatibility
4. All existing functionality is preserved exactly
5. All existing Playwright tests continue to pass
6. Service instantiation and dependency injection is handled properly in reader context
7. Unit tests cover any newly introduced adapters/mappers that translate service results into legacy state shapes; untouched legacy code can remain without additional tests

## Tasks / Subtasks
- [ ] Identify current logic delegation points (AC: 1, 2)
  - [ ] Audit `src/reader/text.ts` for timing calculation calls
  - [ ] Audit `src/reader/selection-loader.ts` for preprocessing calls
  - [ ] Map existing function calls to new service methods
- [ ] Refactor text.ts to use TimingService (AC: 1)
  - [ ] Import TimingService into `src/reader/text.ts`
  - [ ] Replace direct timing function calls with service method calls
  - [ ] Instantiate TimingService appropriately (dependency injection)
  - [ ] Ensure timing preferences are passed correctly to service
  - [ ] Maintain existing error handling patterns
- [ ] Refactor selection-loader.ts to use AIPreprocessingService (AC: 2)
  - [ ] Import AIPreprocessingService into `src/reader/selection-loader.ts`
  - [ ] Replace direct preprocessing calls with service method calls
  - [ ] Instantiate AIPreprocessingService with proper dependencies
  - [ ] Ensure preprocessing configuration is passed correctly to service
  - [ ] Maintain existing error handling and fallback logic
- [ ] Maintain legacy state compatibility (AC: 3)
  - [ ] Ensure service results are stored in existing state variables
  - [ ] Maintain existing variable names and formats
  - [ ] Preserve existing state synchronization patterns
  - [ ] Keep legacy state as the source of truth for UI
- [ ] Handle service instantiation and dependencies
  - [ ] Create TimingService instance in reader context
  - [ ] Create AIPreprocessingService instance with proper dependencies (StorageService, etc.)
  - [ ] Ensure services have access to necessary configuration
  - [ ] Handle service lifecycle appropriately
- [ ] Preserve existing functionality (AC: 4)
  - [ ] Ensure text preprocessing behavior is identical
  - [ ] Ensure timing calculations produce same results
  - [ ] Maintain all error handling and edge case behavior
  - [ ] Preserve performance characteristics
- [ ] Verification and testing (AC: 5, 6)
  - [ ] Run `npm test` to ensure all Playwright tests pass
  - [ ] Test reader functionality manually in browser
  - [ ] Test timing accuracy with various text samples
  - [ ] Test preprocessing with OpenAI features
  - [ ] Verify service instantiation works correctly
  - [ ] Run `npm run build:chrome` to verify build integrity
  - [ ] Run `npm run lint` and `npm run typecheck` to ensure code quality

## Dev Notes

### Architecture Context
This story implements Phase 3, Step 3.3 of the refactoring plan, completing the service layer extraction by migrating the reader components to use the new services while maintaining backward compatibility.

[Source: docs/refactoring/refactoring_plan.md#phase-3-service-layer-extraction]

### Current Reader Logic Flow
The reader currently has monolithic logic in:
- `src/reader/text.ts` - Handles text preprocessing and timing chunk generation
- `src/reader/selection-loader.ts` - Loads selection, processes text, and updates UI

These modules currently call timing and preprocessing functions directly and manipulate state variables directly.

[Source: docs/architecture.md#reader-ui-modular-architecture]

### Service Integration Pattern
```typescript
// Example integration in text.ts
import { TimingService } from './timing/timing.service.js'
import { useReaderStore } from './state/reader.store.js'

const timingService = new TimingService()

// Replace direct timing calls
const chunks = timingService.calculateWordTiming(text, {
  wordsPerMinute: state.wordsPerMinute,
  // ... other preferences
})

// Store results in legacy state for compatibility
state.words = chunks
state.currentIndex = 0
```

### Dependency Management
Services need proper instantiation:
- TimingService: No dependencies (pure functions)
- AIPreprocessingService: Requires StorageService for API key access

### Technical Requirements
- Service calls must produce identical results to existing logic
- Error handling must be preserved exactly
- Performance characteristics should remain the same
- Legacy state variables must continue to be the source of truth

### Risk Mitigation
- Changes are refactoring only (no functional changes)
- Legacy state system continues to drive UI
- Services are called from existing code paths
- All existing tests must continue to pass without modification

### Migration Strategy
This creates a hybrid system where:
1. Services handle business logic
2. Results are stored in legacy state
3. UI continues to read from legacy state
4. Future stories will migrate UI to read from services/store directly

### Testing Standards
- Add unit tests for new/refactored glue code (adapters, mappers, DI wiring). Focus strictly on new code introduced by this story.
- All existing Playwright tests must pass without modification
- Manual verification of reader functionality required
- Focus on behavioral equivalence verification
- Performance testing to ensure no regression

### Linting Strategy
- When introducing new lint or type checks, add existing files to the ignore list so the baseline continues to pass.
- Whenever you modify one of the ignored files, remove it from the ignore list and resolve any violations so that the updated code complies with the stricter rules.
- Remove this story's touched files from the `.eslintignore` baseline created in Story 1.1 before committing.


### Critical Success Criteria
- Business logic successfully delegated to services
- All functionality preserved exactly
- Legacy state system continues to work
- Foundation prepared for UI migration in next phase

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-25 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*This section will be populated by the QA agent after implementation review*
