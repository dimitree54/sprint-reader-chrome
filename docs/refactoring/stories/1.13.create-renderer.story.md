# Story 1.13: Create Renderer Component

## Status
Draft

## Story
**As a** developer refactoring the Sprint Reader extension,
**I want** a dedicated Renderer component that subscribes to the Zustand store and updates the DOM,
**so that** UI rendering is decoupled from business logic and driven by centralized state.

## Acceptance Criteria
1. `Renderer` module is created in `src/reader/ui/renderer.ts`
2. Renderer subscribes to the Zustand store for state updates
3. Initial word display rendering is migrated from `render.ts` to the new Renderer
4. Renderer updates DOM based on store state changes only
5. Initial word renders correctly when reader loads
6. Playback functionality may be temporarily broken (expected during transition)
7. Existing Playwright tests for initial rendering continue to pass

## Tasks / Subtasks
- [ ] Create Renderer module structure (AC: 1)
  - [ ] Create `src/reader/ui/renderer.ts` file
  - [ ] Define Renderer class or module structure
  - [ ] Set up proper TypeScript interfaces for rendering operations
- [ ] Implement store subscription (AC: 2)
  - [ ] Import and subscribe to the Zustand reader store
  - [ ] Set up subscription to relevant state changes
  - [ ] Implement unsubscription for cleanup
  - [ ] Handle subscription lifecycle properly
- [ ] Migrate word display rendering (AC: 3)
  - [ ] Move word rendering logic from `src/reader/render.ts` to Renderer
  - [ ] Implement DOM updates based on store state
  - [ ] Maintain existing visual formatting and styling
  - [ ] Preserve word highlighting and positioning logic
- [ ] Ensure store-driven updates (AC: 4)
  - [ ] Renderer should only update DOM in response to store changes
  - [ ] Remove any direct state manipulation from renderer
  - [ ] Ensure renderer is purely reactive to state
  - [ ] Handle store state initialization properly
- [ ] Verify initial rendering (AC: 5)
  - [ ] Ensure initial word displays correctly when reader loads
  - [ ] Test with various text samples
  - [ ] Verify visual formatting matches existing behavior
  - [ ] Test with different themes and font sizes
- [ ] Handle temporary functionality loss (AC: 6)
  - [ ] Document expected temporary issues with playback
  - [ ] Ensure initial rendering works even if playback is broken
  - [ ] Prepare for subsequent stories to restore full functionality
- [ ] Verification and testing (AC: 7)
  - [ ] Run tests related to initial rendering
  - [ ] Test reader loading in browser manually
  - [ ] Verify word display appears correctly
  - [ ] Run `npm run build:chrome` to verify build integrity
  - [ ] Run `npm run typecheck` and `npm run lint` to ensure code quality
  - [ ] Temporarily disable or expect failures in playback-related tests

## Dev Notes

### Architecture Context
This story implements Phase 4, Step 4.1 of the refactoring plan, creating the first major UI component that subscribes to the new state store. This is the critical transition point where UI begins to be driven by centralized state.

[Source: docs/refactoring/refactoring_plan.md#phase-4-isolate-rendering-and-user-controls]

### Current Rendering Architecture
The reader currently handles rendering in:
- `src/reader/render.ts` - Main DOM manipulation and word display
- `src/reader/visual-effects.ts` - Letter highlighting and positioning
- Direct DOM manipulation scattered throughout other reader modules

[Source: docs/architecture.md#reader-ui-modular-architecture]

### Renderer Design Pattern
```typescript
class Renderer {
  private unsubscribe: () => void

  constructor() {
    // Subscribe to store changes
    this.unsubscribe = useReaderStore.subscribe((state) => {
      this.updateWordDisplay(state.words[state.playbackIndex])
      this.updateProgress(state.progress)
      // ... other DOM updates
    })
  }

  private updateWordDisplay(currentWord: WordItem) {
    // Update DOM elements based on current word
  }

  destroy() {
    this.unsubscribe()
  }
}
```

### Technical Requirements
- Must subscribe to Zustand store for reactive updates
- Should only perform DOM manipulation (no business logic)
- Must preserve existing visual formatting and effects
- Should handle store state initialization gracefully

### Expected Transition Issues
This story intentionally creates a hybrid state where:
- Initial rendering works (driven by store)
- Playback may be broken (legacy playback still uses old state)
- Some UI elements may not update (not yet connected to store)

This is expected and will be resolved in subsequent stories.

### Migration Strategy
1. Create renderer that subscribes to store
2. Migrate one piece of rendering logic (word display)
3. Ensure basic rendering works
4. Subsequent stories will:
   - Migrate controls to update store
   - Migrate playback to update store
   - Complete the reactive UI system

### Testing Standards
- Focus on initial rendering functionality
- Expect some test failures related to playback (document these)
- Manual browser testing crucial for verifying UI appearance
- Visual regression testing important

### Linting Strategy
- When introducing new lint or type checks, add existing files to the ignore list so the baseline continues to pass.
- Whenever you modify one of the ignored files, remove it from the ignore list and resolve any violations so that the updated code complies with the stricter rules.
- Remove this story's touched files from the `.eslintignore` baseline created in Story 1.1 before committing.


### Critical Success Criteria
- Renderer successfully subscribes to store
- Initial word display works correctly
- Foundation established for reactive UI system
- Store-driven rendering pattern proven

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-25 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*This section will be populated by the QA agent after implementation review*