# Story 1.14: Create UIControls Module

## Status
Draft

## Story
**As a** developer refactoring the Sprint Reader extension,
**I want** a dedicated UIControls module that handles user interactions and updates the Zustand store,
**so that** user controls are decoupled from rendering and consistently update centralized state.

## Acceptance Criteria
1. `UIControls` module is created in `src/reader/ui/controls.ts`
2. All event listeners from old `controls.ts` are moved to the new module
3. Event handlers call actions on the Zustand store instead of directly manipulating state
4. UI controls (play/pause, WPM slider, theme toggle) update store state correctly
5. Store state changes trigger appropriate renderer updates
6. User interactions work correctly in the browser
7. Existing functionality is preserved through the store-renderer connection

## Tasks / Subtasks
- [ ] Create UIControls module structure (AC: 1)
  - [ ] Create `src/reader/ui/controls.ts` file
  - [ ] Define UIControls class or module structure
  - [ ] Set up proper TypeScript interfaces for control operations
- [ ] Migrate event listeners (AC: 2)
  - [ ] Move all `addEventListener` calls from old `controls.ts`
  - [ ] Migrate play/pause button click handlers
  - [ ] Migrate WPM slider change handlers
  - [ ] Migrate theme toggle click handlers
  - [ ] Migrate keyboard event handlers
  - [ ] Migrate any other UI control event listeners
- [ ] Update handlers to use store actions (AC: 3)
  - [ ] Replace direct state manipulation with store action calls
  - [ ] Use `useReaderStore.getState().togglePlay()` for play/pause
  - [ ] Use `useReaderStore.getState().setWPM()` for speed changes
  - [ ] Use `useReaderStore.getState().toggleTheme()` for theme changes
  - [ ] Ensure all handlers update store instead of legacy state
- [ ] Verify UI control functionality (AC: 4)
  - [ ] Test play/pause button updates store state correctly
  - [ ] Test WPM slider updates store state correctly
  - [ ] Test theme toggle updates store state correctly
  - [ ] Test keyboard shortcuts update store state correctly
  - [ ] Verify preference persistence continues to work
- [ ] Ensure renderer responds to control changes (AC: 5)
  - [ ] Verify renderer updates when play/pause state changes
  - [ ] Verify renderer updates when WPM changes
  - [ ] Verify renderer updates when theme changes
  - [ ] Test that store changes trigger appropriate DOM updates
- [ ] Test user interactions (AC: 6, 7)
  - [ ] Test all controls work correctly in browser
  - [ ] Test preference changes persist between sessions
  - [ ] Test keyboard shortcuts continue to work
  - [ ] Verify visual feedback for control interactions
- [ ] Verification and integration testing
  - [ ] Run `npm test` to check for any passing tests
  - [ ] Test reader controls manually in browser
  - [ ] Verify store-renderer-controls cycle works correctly
  - [ ] Run `npm run build:chrome` to verify build integrity
  - [ ] Run `npm run typecheck` and `npm run lint` to ensure code quality

## Dev Notes
### Linting Strategy
- When introducing new lint or type checks, add existing files to the ignore list so the baseline continues to pass.
- Whenever you modify one of the ignored files, remove it from the ignore list and resolve any violations so that the updated code complies with the stricter rules.
- Remove this story's touched files from the `.eslintignore` baseline created in Story 1.1 before committing.


### Architecture Context
This story implements Phase 4, Step 4.2 of the refactoring plan, completing the UI decoupling by creating controls that update the store instead of directly manipulating state. This establishes the reactive UI pattern.

[Source: docs/refactoring/refactoring_plan.md#phase-4-isolate-rendering-and-user-controls]

### Current Controls Architecture
The reader currently handles user interactions in:
- `src/reader/controls.ts` - Event listeners and direct state manipulation
- Direct DOM event binding scattered throughout reader modules
- Direct variable assignment for preference changes

[Source: docs/architecture.md#reader-ui-modular-architecture]

### UIControls Design Pattern
```typescript
class UIControls {
  constructor() {
    this.bindEventListeners()
  }

  private bindEventListeners() {
    // Play/pause button
    document.getElementById('playButton')?.addEventListener('click', () => {
      useReaderStore.getState().togglePlay()
    })

    // WPM slider
    document.getElementById('wpmSlider')?.addEventListener('input', (e) => {
      const wpm = parseInt((e.target as HTMLInputElement).value)
      useReaderStore.getState().setWPM(wpm)
    })

    // Theme toggle
    document.getElementById('themeToggle')?.addEventListener('click', () => {
      useReaderStore.getState().toggleTheme()
    })
  }
}
```

### Store Actions Integration
The controls will use store actions:
- `togglePlay()` - Play/pause control
- `setWPM(wpm)` - Speed control
- `toggleTheme()` - Theme switching
- `setPlaybackIndex(index)` - Word navigation
- Other actions as defined in the store

### Technical Requirements
- Must preserve all existing user interaction patterns
- Should maintain preference persistence through store actions
- Must ensure store actions trigger renderer updates
- Should handle keyboard shortcuts correctly

### Reactive UI Flow
The complete flow will be:
1. User interaction (click, keyboard, slider)
2. UIControls calls store action
3. Store state updates
4. Renderer subscribes to changes and updates DOM
5. Preferences persist through store actions

### Integration Points
- Controls module must work with existing DOM structure
- Store actions must handle preference persistence
- Renderer must respond to all control-triggered state changes

### Testing Strategy
- Manual browser testing crucial for user interaction verification
- Test the complete reactive cycle (controls → store → renderer → DOM)
- Verify preference persistence works through new system
- Test keyboard shortcuts and accessibility

### Expected Results
After this story:
- Controls update store instead of direct state
- Renderer updates in response to control interactions
- Complete reactive UI pattern established
- Foundation ready for playback service integration

### Critical Success Criteria
- All user controls work correctly through store
- Renderer responds appropriately to control changes
- Preference persistence continues to function
- Reactive UI pattern fully operational

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-25 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*This section will be populated by the QA agent after implementation review*