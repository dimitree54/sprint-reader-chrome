# Story 1.17: Deprecate Legacy Reader State

## Status
Draft

## Story
**As a** developer completing the architecture refactoring,
**I want** all remaining uses of the legacy reader state system replaced with Zustand store usage,
**so that** the application logic exclusively uses the new centralized state management system.

## Acceptance Criteria
1. All remaining uses of the old `reader/state.ts` module are identified and migrated
2. All components and services use the Zustand store exclusively
3. Legacy state synchronization code is removed (no longer needed)
4. All state management goes through the Zustand store
5. All existing functionality is preserved exactly
6. All Playwright tests continue to pass
7. Application performance is maintained or improved

## Tasks / Subtasks
- [ ] Audit remaining legacy state usage (AC: 1)
  - [ ] Search codebase for imports from `src/reader/state.ts`
  - [ ] Identify any direct references to legacy state variables
  - [ ] Document all remaining migration points
  - [ ] Create comprehensive list of components that need updates
- [ ] Migrate remaining reader components (AC: 2)
  - [ ] Update any remaining uses in `src/reader/index.ts`
  - [ ] Update any remaining uses in `src/reader/selection-loader.ts`
  - [ ] Update any remaining uses in other reader modules
  - [ ] Update services to use store instead of legacy state
- [ ] Remove legacy state synchronization (AC: 3)
  - [ ] Remove sync code added in Story 1.9 (no longer needed)
  - [ ] Clean up temporary synchronization mechanisms
  - [ ] Remove any bridge code between old and new state systems
  - [ ] Ensure clean separation with only store-based state
- [ ] Ensure exclusive store usage (AC: 4)
  - [ ] Verify all state reads come from Zustand store
  - [ ] Verify all state writes go through store actions
  - [ ] Ensure no component bypasses the store
  - [ ] Confirm complete state centralization
- [ ] Preserve functionality (AC: 5)
  - [ ] Test all reader functionality works identically
  - [ ] Verify text loading and processing
  - [ ] Verify playback controls and timing
  - [ ] Verify preference management
  - [ ] Test error handling and edge cases
- [ ] Comprehensive testing (AC: 6)
  - [ ] Run full Playwright test suite
  - [ ] Fix any test failures from state migration
  - [ ] Test all user interaction scenarios
  - [ ] Verify data persistence across sessions
- [ ] Performance verification (AC: 7)
  - [ ] Test reader loading performance
  - [ ] Test playback performance
  - [ ] Verify memory usage is not increased
  - [ ] Test with large text samples
- [ ] Final verification
  - [ ] Manual testing of complete reader workflow
  - [ ] Test all extension features end-to-end
  - [ ] Run `npm run build:chrome` to verify build integrity
  - [ ] Run `npm run typecheck` and `npm run lint` to ensure code quality

## Dev Notes
### Linting Strategy
- When introducing new lint or type checks, add existing files to the ignore list so the baseline continues to pass.
- Whenever you modify one of the ignored files, remove it from the ignore list and resolve any violations so that the updated code complies with the stricter rules.
- Remove this story's touched files from the `.eslintignore` baseline created in Story 1.1 before committing.


### Architecture Context
This story implements Phase 5, Step 5.2 of the refactoring plan, completing the state migration by removing all legacy state usage and ensuring exclusive use of the Zustand store.

[Source: docs/refactoring/refactoring_plan.md#phase-5-implement-playbackservice-and-finalize-reader]

### Current State System Status
At this point in the refactoring:
- Zustand store is operational and synchronized
- Services use store for state management
- UI components (Renderer, Controls) use store
- Legacy state may still be used in some components
- Synchronization code from Story 1.9 can be removed

### Migration Targets
Components that may still use legacy state:
- Reader initialization logic
- Text loading and processing
- Any remaining selection handling
- Error handling and fallback scenarios

### Store Consolidation
Ensure all state operations go through store:
```typescript
// Replace any remaining patterns like:
// state.playing = true
// With:
useReaderStore.getState().setStatus('playing')

// Replace any remaining patterns like:
// const currentWord = state.words[state.currentIndex]
// With:
const { words, playbackIndex } = useReaderStore.getState()
const currentWord = words[playbackIndex]
```

### Synchronization Cleanup
Remove synchronization code added in Story 1.9:
- Remove sync calls after legacy state mutations
- Remove bridge code between systems
- Clean up any temporary compatibility layers

### Technical Requirements
- Must maintain identical functionality
- Should not introduce performance regressions
- Must preserve all existing behavior exactly
- Should result in cleaner, more maintainable code

### Testing Strategy
- Comprehensive testing required since this removes the safety net
- All user scenarios must be tested
- Pay special attention to edge cases and error handling
- Performance testing to ensure no regressions

### Risk Mitigation
- Thorough testing before removing legacy state
- Incremental migration of remaining components
- Keep detailed notes of changes for potential rollback
- Test all extension features, not just reader

### Expected Architecture State
After this story:
- Single source of truth: Zustand store
- All components use store exclusively
- Clean separation of concerns
- No duplicate state management systems
- Simplified and more maintainable codebase

### Critical Success Criteria
- All legacy state usage eliminated
- All functionality preserved exactly
- All tests passing
- Performance maintained or improved
- Clean, unified state management

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-25 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*This section will be populated by the QA agent after implementation review*