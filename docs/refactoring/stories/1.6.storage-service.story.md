# Story 1.6: Create StorageService

## Status
Draft

## Story
**As a** developer refactoring the Sprint Reader extension,
**I want** a centralized StorageService that manages all extension storage operations,
**so that** storage logic is abstracted, testable, and consistently managed throughout the application.

## Acceptance Criteria
1. `StorageService` class is created in `src/core/storage.service.ts`
2. All storage functions from `src/common/storage.ts` are moved into the service class
3. Service uses the `BrowserApiService` for underlying storage operations
4. Service maintains backward compatibility with existing storage usage patterns
5. Unit tests are created for the `StorageService` using mocked `BrowserApiService`
6. All existing Playwright tests continue to pass

## Tasks / Subtasks
- [ ] Create StorageService class (AC: 1)
  - [ ] Create `src/core/storage.service.ts` file
  - [ ] Define StorageService class with dependency on BrowserApiService
  - [ ] Implement constructor that accepts BrowserApiService instance
- [ ] Migrate storage logic (AC: 2)
  - [ ] Move all functions from `src/common/storage.ts` into service methods
  - [ ] Move storage helper functions from any other storage-related files
  - [ ] Ensure all canonical storage keys are maintained
  - [ ] Convert callback-driven storage API to promise-based methods
- [ ] Integrate with BrowserApiService (AC: 3)
  - [ ] Use BrowserApiService instead of direct browser storage API calls
  - [ ] Ensure proper error handling and promise chaining
  - [ ] Maintain cross-browser compatibility through service abstraction
- [ ] Ensure backward compatibility (AC: 4)
  - [ ] Verify service methods match existing storage function signatures
  - [ ] Provide smooth migration path for existing imports
  - [ ] Ensure no breaking changes to calling code
- [ ] Create unit tests (AC: 5)
  - [ ] Create `src/core/storage.service.spec.ts` test file
  - [ ] Write tests for all public storage methods
  - [ ] Mock BrowserApiService in tests
  - [ ] Test error conditions and edge cases
  - [ ] Follow AAA pattern (Arrange, Act, Assert)
- [ ] Verification and testing (AC: 6)
  - [ ] Run unit tests to ensure StorageService functionality
  - [ ] Run `npm test` to ensure all Playwright tests pass
  - [ ] Run `npm run build:chrome` to verify build integrity
  - [ ] Test storage operations manually in browser
  - [ ] Run `npm run lint` and `npm run typecheck` to ensure code quality

## Dev Notes

### Architecture Context
This story implements Phase 1, Step 1.3 of the refactoring plan, creating the second core service that abstracts storage operations and depends on the previously created BrowserApiService.

[Source: docs/refactoring/refactoring_plan.md#phase-1-core-services-abstraction]

### Current Storage Architecture
The extension currently has storage logic in:
- `src/common/storage.ts` - Main storage helper functions
- Direct browser storage API calls scattered throughout the application

Storage operations include:
- Reader preferences (words-per-minute, theme settings)
- OpenAI API key and configuration
- Extension settings and state

[Source: docs/architecture.md#cross-cutting-modules]

### Service Interface Design
```typescript
class StorageService {
  constructor(private browserApi: BrowserApiService) {}

  // Core storage operations
  async get(keys?: string | string[]): Promise<any>
  async set(items: any): Promise<void>
  async remove(keys: string | string[]): Promise<void>
  async clear(): Promise<void>

  // Preference-specific methods
  async getReaderPreferences(): Promise<ReaderPreferences>
  async setReaderPreferences(prefs: ReaderPreferences): Promise<void>
  async getOpenAIConfig(): Promise<OpenAIConfig>
  async setOpenAIConfig(config: OpenAIConfig): Promise<void>
}
```

### Technical Requirements
- Must use BrowserApiService for all underlying browser storage operations
- Should maintain promise-based API from existing storage helpers
- Must preserve all existing storage keys and data formats
- Should provide type-safe interfaces for common storage objects

### Testing Requirements
Unit tests must cover:
- All public methods with various input scenarios
- Error handling for storage failures
- Mocking of BrowserApiService dependency
- Type safety and data validation
\n+Note: Focus tests on the newly created StorageService. Untouched legacy helpers may remain without additional tests for now.

### Migration Strategy
The service will initially coexist with existing storage helpers to ensure zero breaking changes. Subsequent stories will migrate calling code to use the service.

### Testing Standards
- Create comprehensive unit tests using Vitest
- Mock BrowserApiService dependency for isolated testing
- Ensure all existing Playwright tests continue to pass
- Test both success and error scenarios
 - Do not add tests for untouched legacy modules at this stage

### Linting Strategy
- When introducing new lint or type checks, add existing files to the ignore list so the baseline continues to pass.
- Whenever you modify one of the ignored files, remove it from the ignore list and resolve any violations so that the updated code complies with the stricter rules.
- Remove this story's touched files from the `.eslintignore` baseline created in Story 1.1 before committing.


### Critical Success Criteria
- Storage operations centralized in testable service
- BrowserApiService integration working correctly
- Unit tests demonstrate service functionality and testability
- No functional regression in extension storage behavior
- Foundation established for other services to use storage

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-25 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*This section will be populated by the QA agent after implementation review*
